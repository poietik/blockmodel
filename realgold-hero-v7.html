<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RealGold — Hero (v9 LITE, transparent)</title>
<link rel="dns-prefetch" href="https://unpkg.com">
<link rel="preconnect" href="https://unpkg.com" crossorigin>
<style>
  html,body{height:100%;background:transparent!important;margin:0}
  #rg-root{position:fixed;inset:0;background:transparent!important;touch-action:none;cursor:grab}
  #rg-root.scrubbing{cursor:grabbing}
  canvas{display:block;width:100%;height:100%;background:transparent!important}
  .rg-fallback{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#ccc;font:14px/1.4 ui-sans-serif,system-ui}
</style>
</head>
<body>
<div id="rg-root" aria-label="3D gold-in-ground visualization; drag horizontally to scrub the scan" role="img"></div>
<noscript><div class="rg-fallback">Enable JavaScript to view the 3D visualization.</div></noscript>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const QS=new URLSearchParams(location.search);
const ZOOM=Math.max(0.75,Math.min(2.0,parseFloat(QS.get('zoom')||'1.35'))); // bigger by default
const FORCE_DPR=parseFloat(QS.get('dpr')||'0');

const el=document.getElementById('rg-root');
const IS_MOBILE=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const supportsWebGL=(()=>{try{const c=document.createElement('canvas');return !!(c.getContext('webgl')||c.getContext('experimental-webgl'));}catch(e){return false;}})();
if(!supportsWebGL){ el.innerHTML='<div class="rg-fallback">No WebGL</div>'; throw new Error('No WebGL'); }

// Transparent renderer
const DPR=Math.min((FORCE_DPR>0?FORCE_DPR:(window.devicePixelRatio||1)), IS_MOBILE?1.25:2);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true,powerPreference:IS_MOBILE?'low-power':'high-performance'});
renderer.setPixelRatio(DPR);
renderer.setSize(el.clientWidth, el.clientHeight);
renderer.setClearColor(0x000000,0);
renderer.localClippingEnabled=true;
el.appendChild(renderer.domElement);

const scene=new THREE.Scene();

// Camera (ZOOM reduces ortho size so cube looks larger)
let camera;
const BASE_ORTHO=3.6;
function makeOrtho(){
  const aspect=el.clientWidth/el.clientHeight;
  const h=(BASE_ORTHO/ZOOM), w=h*aspect;
  camera=new THREE.OrthographicCamera(-w,w,h,-h,0.1,100);
  camera.position.set(4,4,4);
  camera.lookAt(0,0,0);
}
makeOrtho();
addEventListener('resize',()=>{renderer.setSize(el.clientWidth, el.clientHeight); makeOrtho();});

// Helpers/const
const SIZE=2.4, HALF=SIZE/2, SCAN_H=0.008*SIZE, STRATA_COUNT=IS_MOBILE?24:48, gridTop=IS_MOBILE?64:96;
const lerp=(a,b,t)=>a+(b-a)*t;
const clamp01=x=>Math.max(0,Math.min(1,x));
const fade=t=>t*t*t*(t*(t*6-15)+10);
const mulberry32=a=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296};
const yFor=t=>THREE.MathUtils.lerp(HALF-0.002-SCAN_H*0.5, -HALF+0.002+SCAN_H*0.5, t);

// Wire cube
scene.add(new THREE.LineSegments(
  new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE,SIZE,SIZE)),
  new THREE.LineBasicMaterial({color:0xeaeaea,transparent:true,opacity:0.9})
));

// Crown surface
const landGeo=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop);
const rand=mulberry32(777);
const grad=[]; for(let i=0;i<=gridTop;i++) grad[i]=Array(gridTop+1).fill(0).map(()=>({x:rand()*2-1,y:rand()*2-1}));
const noise=(x,y)=>{const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi;
  const dot=(ix,iy)=>{const g=grad[(iy%(gridTop+1)+gridTop+1)%(gridTop+1)][(ix%(gridTop+1)+gridTop+1)%(gridTop+1)]; return g.x*(x-ix)+g.y*(y-iy);};
  const u=fade(xf), v=fade(yf);
  const n00=dot(xi,yi), n10=dot(xi+1,yi), n01=dot(xi,yi+1), n11=dot(xi+1,yi+1);
  return lerp(lerp(n00,n10,u), lerp(n01,n11,u), v);
};
const fbm=(x,y)=>{let val=0,amp=0.6,freq=1.0; for(let i=0;i<4;i++){val+=amp*noise(x*freq,y*freq); amp*=0.5; freq*=2.02;} return val;};
const lpos=landGeo.attributes.position;
for(let i=0;i<lpos.count;i++){const x=lpos.getX(i)/SIZE+10.5, y=lpos.getY(i)/SIZE+10.5; lpos.setZ(i, fbm(x,y)*0.48*HALF);}
lpos.needsUpdate=true; landGeo.computeVertexNormals();
const land=new THREE.LineSegments(new THREE.EdgesGeometry(landGeo), new THREE.LineBasicMaterial({color:0xeaeaea,transparent:true,opacity:1}));
land.rotation.x=-Math.PI/2; land.position.y=HALF-0.001; scene.add(land);
const topHeights=new Float32Array(lpos.count); for(let i=0;i<lpos.count;i++) topHeights[i]=lpos.getZ(i);

// Strata stack
const strataGroup=new THREE.Group(); scene.add(strataGroup);
function makeStratum(i){
  const t=i/(STRATA_COUNT-1), g=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop), p=g.attributes.position;
  const blend=lerp(0.75,0.35,t), amp=lerp(0.20,0.10,t)*HALF, freq=1.0+t*1.6, off=t*3.14159;
  for(let j=0;j<p.count;j++){
    const x=p.getX(j)/SIZE+10.5, y=p.getY(j)/SIZE+10.5; const base=topHeights[j]||0;
    const n=fbm((x+off)*freq,(y-off)*freq);
    const candidate=(blend*base+(1.0-blend)*(n*0.48*HALF));
    p.setZ(j,(candidate/(0.48*HALF))*amp);
  }
  p.needsUpdate=true; g.computeVertexNormals();
  const edges=new THREE.EdgesGeometry(g), opacity=lerp(0.5,0.1,t);
  const mat=new THREE.LineBasicMaterial({color:0xeaeaea,transparent:true,opacity});
  const mesh=new THREE.LineSegments(edges,mat); mesh.rotation.x=-Math.PI/2; mesh.position.y=yFor(t); mesh.userData.layerIndex=i; return mesh;
}
for(let i=1;i<STRATA_COUNT;i++) strataGroup.add(makeStratum(i));

// Surface gold specks
const goldGroup=new THREE.Group(); scene.add(goldGroup);
function makeGoldPoints(i){
  const t=i/(STRATA_COUNT-1), y=yFor(t), count=IS_MOBILE?40:80, geo=new THREE.BufferGeometry(), pos=new Float32Array(count*3);
  let n=0, tries=0; while(n<count && tries<count*10){ tries++;
    const x=(Math.random()-0.5)*SIZE*0.92, z=(Math.random()-0.5)*SIZE*0.92;
    const sx=x/SIZE+10.5+t*3.14159, sy=z/SIZE+10.5-t*3.14159, freq=1.0+t*1.6;
    const v=fbm(sx*freq, sy*freq);
    if(v>0.36+t*0.1){ pos[n*3]=x; pos[n*3+1]=y+(Math.random()-0.5)*SCAN_H*0.6; pos[n*3+2]=z; n++; }
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos.subarray(0,n*3),3));
  const mat=new THREE.PointsMaterial({color:0xc9a227, size:IS_MOBILE?0.014:0.018, transparent:true, opacity:0.45, depthWrite:false, blending:THREE.AdditiveBlending});
  const pts=new THREE.Points(geo,mat); pts.userData.layerIndex=i; return pts;
}
for(let i=0;i<STRATA_COUNT;i++) goldGroup.add(makeGoldPoints(i));

// Scan slice + glow trail
const SCAN=new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE*0.985,SCAN_H,SIZE*0.985)), new THREE.LineBasicMaterial({color:0xc9a227}));
const GLOW=new THREE.Mesh(new THREE.BoxGeometry(SIZE*0.985,SCAN_H,SIZE*0.985), new THREE.MeshBasicMaterial({color:0xc9a227,transparent:true,opacity:0.12,blending:THREE.AdditiveBlending}));
const GLOW_T1=GLOW.clone(); GLOW_T1.material=GLOW.material.clone(); GLOW_T1.material.opacity=0.07; GLOW_T1.scale.y=1.8;
const GLOW_T2=GLOW.clone(); GLOW_T2.material=GLOW.material.clone(); GLOW_T2.material.opacity=0.04; GLOW_T2.scale.y=3.0;
scene.add(SCAN,GLOW,GLOW_T1,GLOW_T2);

// Clip land above slice
const plane=new THREE.Plane(new THREE.Vector3(0,-1,0),0);
const clipMat=new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true,clippingPlanes:[plane],transparent:true,opacity:0.18});
const clipLand=new THREE.Mesh(landGeo.clone(),clipMat); clipLand.rotation.x=-Math.PI/2; clipLand.position.y=HALF-0.001; scene.add(clipLand);

// --- Diagonal 2× orebody (point-cloud, fast & reliable) ---
const oreUniforms={uSliceY:{value:0.0},uSliceLagY:{value:0.0},uW:{value:0.10}};
const ORE_POINTS=IS_MOBILE?4000:7000;
const rngOre=mulberry32(424242);
const opos=new Float32Array(ORE_POINTS*3);
const p0=new THREE.Vector3(-HALF*0.65,-HALF*0.25, HALF*0.65);
const p1=new THREE.Vector3( HALF*0.65, HALF*0.65,-HALF*0.65);
const dir=new THREE.Vector3().subVectors(p1,p0);
for(let i=0;i<ORE_POINTS;i++){
  const t=i/ORE_POINTS, base=new THREE.Vector3().copy(p0).addScaledVector(dir, t+(rngOre()-0.5)*0.06);
  base.x+=(rngOre()-0.5)*0.60; base.y+=(rngOre()-0.5)*0.34; base.z+=(rngOre()-0.5)*0.60; // 2× envelope
  opos[i*3]=base.x; opos[i*3+1]=base.y; opos[i*3+2]=base.z;
}
const oreGeo=new THREE.BufferGeometry(); oreGeo.setAttribute('position', new THREE.BufferAttribute(opos,3));
const oreMat=new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  uniforms:{ uSliceY:oreUniforms.uSliceY, uSliceLagY:oreUniforms.uSliceLagY, uW:oreUniforms.uW,
             uBase:{value:new THREE.Color(0x4a3d12)}, uGold:{value:new THREE.Color(0xc9a227)},
             uSize:{value:IS_MOBILE?2.0:2.6} },
  vertexShader:`
    uniform float uSliceY,uSliceLagY,uW,uSize; varying float vH;
    void main(){
      vec4 world=modelMatrix*vec4(position,1.0);
      float d0=abs(world.y-uSliceY), d1=abs(world.y-uSliceLagY);
      vH=smoothstep(uW*1.2,0.0,min(d0,d1));
      gl_Position=projectionMatrix*viewMatrix*world;
      gl_PointSize=uSize*(1.0+1.6*vH);
    }`,
  fragmentShader:`
    precision mediump float; varying float vH; uniform vec3 uBase,uGold;
    void main(){
      vec2 uv=gl_PointCoord-0.5; float r=length(uv); if(r>0.5) discard;
      float core=smoothstep(0.5,0.0,r);
      vec3 col=mix(uBase,uGold,vH);
      float a=core*(0.10+0.90*vH);
      gl_FragColor=vec4(col,a);
    }`
});
const orePts=new THREE.Points(oreGeo,oreMat); scene.add(orePts);

// Sparkle highlight near slice
const sparkGeo=new THREE.BufferGeometry();
const SPARK=IS_MOBILE?1000:1600; const s=new Float32Array(SPARK*3);
for(let i=0;i<SPARK;i++){ s[i*3]=(Math.random()-0.5)*SIZE*0.86; s[i*3+1]=(Math.random()-0.5)*SIZE*0.86; s[i*3+2]=(Math.random()-0.5)*SIZE*0.86; }
sparkGeo.setAttribute('position', new THREE.BufferAttribute(s,3));
const sparkMat=new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  uniforms:{ uSliceY:{value:0.0}, uSliceLagY:{value:0.0}, uW:{value:0.10}, uSize:{value:IS_MOBILE?1.5:1.8},
             uBase:{value:new THREE.Color(0x5a4a12)}, uGold:{value:new THREE.Color(0xc9a227)} },
  vertexShader:`uniform float uSliceY,uSliceLagY,uW,uSize; varying float vH;
    void main(){ vec4 w=modelMatrix*vec4(position,1.0);
      float d=min(abs(w.y-uSliceY),abs(w.y-uSliceLagY));
      vH=smoothstep(uW*1.2,0.0,d);
      gl_Position=projectionMatrix*viewMatrix*w; gl_PointSize=uSize*(1.0+1.4*vH);} `,
  fragmentShader:`precision mediump float; varying float vH; uniform vec3 uBase,uGold;
    void main(){ vec2 uv=gl_PointCoord-0.5; float r=length(uv); if(r>0.5) discard;
      float core=smoothstep(0.5,0.0,r); vec3 col=mix(uBase,uGold,vH); float a=core*(0.05+0.95*vH);
      gl_FragColor=vec4(col,a);} `
});
scene.add(new THREE.Points(sparkGeo,sparkMat));

// Input + animation
let tAcc=0,dir=1,user=false,resTimer=null; const SPEED=IS_MOBILE?0.144:0.192, RESUME=550;
function setFromX(x){ const r=renderer.domElement.getBoundingClientRect(); tAcc=clamp01((x-r.left)/r.width); }
renderer.domElement.addEventListener('pointerdown',e=>{renderer.domElement.setPointerCapture(e.pointerId);user=true;el.classList.add('scrubbing');clearTimeout(resTimer);setFromX(e.clientX);e.preventDefault();},{passive:false});
renderer.domElement.addEventListener('pointermove',e=>{if(user) setFromX(e.clientX);},{passive:true});
function end(){ if(!user) return; user=false; el.classList.remove('scrubbing'); clearTimeout(resTimer); resTimer=setTimeout(()=>{},RESUME); }
renderer.domElement.addEventListener('pointerup',end,{passive:true});
renderer.domElement.addEventListener('pointerleave',end,{passive:true});
renderer.domElement.addEventListener('pointercancel',end,{passive:true});

let visible=true; (new IntersectionObserver(e=>{visible=e[0]?.isIntersecting??true;},{threshold:0.1})).observe(el);
let yLag1=0.0,yLag2=0.0;

const clock=new THREE.Clock();
function frame(){
  const dt=clock.getDelta();
  if(!user){ tAcc+=dir*SPEED*dt; if(tAcc>1){tAcc=1;dir=-1;} else if(tAcc<0){tAcc=0;dir=1;} }
  const y=yFor(tAcc);
  const k1=4.0,k2=2.0; yLag1+=(y-yLag1)*k1*dt; yLag2+=(y-yLag2)*k2*dt;

  SCAN.position.y=y; GLOW.position.y=y; GLOW_T1.position.y=yLag1; GLOW_T2.position.y=yLag2;
  plane.constant=HALF-y;
  oreUniforms.uSliceY.value=y; oreUniforms.uSliceLagY.value=yLag1;
  sparkMat.uniforms.uSliceY.value=y; sparkMat.uniforms.uSliceLagY.value=yLag1;

  const et=clock.elapsedTime;
  land.rotation.z=Math.sin(et*0.08)*0.002; strataGroup.rotation.z=Math.sin(et*0.06)*0.0015;

  // fade near layer
  const idx=tAcc*(STRATA_COUNT-1), fall=6;
  strataGroup.children.forEach(ch=>{const d=Math.abs((ch.userData.layerIndex||0)-idx); const near=Math.max(0,1-d/fall);
    ch.material.opacity=THREE.MathUtils.lerp(0.05,0.6,near); ch.material.color.setHex(d<0.5?0xffffff:0xeaeaea); });

  renderer.render(scene,camera);
}
function loop(){ if(visible) frame(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
