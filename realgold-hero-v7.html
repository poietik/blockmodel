<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RealGold â€” Hero (v9 LITE, transparent)</title>
<link rel="dns-prefetch" href="https://unpkg.com">
<link rel="preconnect" href="https://unpkg.com" crossorigin>
<style>
  html,body{height:100%;background:transparent!important;margin:0}
  #rg-root{position:fixed;inset:0;background:transparent!important;touch-action:none;cursor:grab}
  #rg-root.scrubbing{cursor:grabbing}
  canvas{display:block;width:100%;height:100%;background:transparent!important}
  .rg-fallback{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#ccc;font:14px/1.4 ui-sans-serif,system-ui}
</style>
</head>
<body>
<div id="rg-root" aria-label="3D gold-in-ground visualization; drag horizontally to scrub the scan" role="img"></div>
<noscript><div class="rg-fallback">Enable JavaScript to view the 3D visualization.</div></noscript>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const QS=new URLSearchParams(location.search);
const ZOOM=Math.max(0.75,Math.min(2.0,parseFloat(QS.get('zoom')||'1.35'))); // bigger by default
const FORCE_DPR=parseFloat(QS.get('dpr')||'0');

const el=document.getElementById('rg-root');
const IS_MOBILE=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const supportsWebGL=(()=>{try{const c=document.createElement('canvas');return !!(c.getContext('webgl')||c.getContext('experimental-webgl'));}catch(e){return false;}})();
if(!supportsWebGL){ el.innerHTML='<div class="rg-fallback">No WebGL</div>'; throw new Error('No WebGL'); }

// Transparent renderer
const DPR=Math.min((FORCE_DPR>0?FORCE_DPR:(window.devicePixelRatio||1)), IS_MOBILE?1.25:2);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true,powerPreference:IS_MOBILE?'low-power':'high-performance'});
renderer.setPixelRatio(DPR);
renderer.setSize(el.clientWidth, el.clientHeight);
renderer.setClearColor(0x000000,0);
renderer.localClippingEnabled=true;
el.appendChild(renderer.domElement);

const scene=new THREE.Scene();

// Camera (ZOOM reduces ortho size so cube looks larger)
let camera;
const BASE_ORTHO=3.6;
function makeOrtho(){
  const aspect=el.clientWidth/el.clientHeight;
  const h=(BASE_ORTHO/ZOOM), w=h*aspect;
  camera=new THREE.OrthographicCamera(-w,w,h,-h,0.1,100);
  camera.position.set(4,4,4);
  camera.lookAt(0,0,0);
}
makeOrtho();
addEventListener('resize',()=>{renderer.setSize(el.clientWidth, el.clientHeight); makeOrtho();});

// Helpers/const
const SIZE=2.4, HALF=SIZE/2, SCAN_H=0.008*SIZE, STRATA_COUNT=IS_MOBILE?24:48, gridTop=IS_MOBILE?64:96;
const lerp=(a,b,t)=>a+(b-a)*t;
const clamp01=x=>Math.max(0,Math.min(1,x));
const fade=t=>t*t*t*(t*(t*6-15)+10);
const mulberry32=a=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296};
const yFor=t=>THREE.MathUtils.lerp(HALF-0.002-SCAN_H*0.5, -HALF+0.002+SCAN_H*0.5, t);

// Wire cube
scene.add(new THREE.LineSegments(
  new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE,SIZE,SIZE)),
  new THREE.LineBasicMaterial({color:0xeaeaea,transparent:true,opacity:0.9})
));

// Crown surface
const landGeo=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop);
const rand=mulberry32(777);
const grad=[]; for(let i=0;i<=gridTop;i++) grad[i]=Array(gridTop+1).fill(0).map(()=>({x:rand()*2-1,y:rand()*2-1}));
const noise=(x,y)=>{const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi;
  const dot=(ix,iy)=>{const g=grad[(iy%(gridTop+1)+gridTop+1)%(gridTop+1)][(ix%(gridTop+1)+gridTop+1)%(gridTop+1)]; return g.x*(x-ix)+g.y*(y-iy);};
  const u=fade(xf), v=fade(yf);
  const n00=dot(xi,yi), n10=dot(xi+1,yi), n01=dot(xi,yi+1), n11=dot(xi+1,yi+1);
  return lerp(lerp(n00,n10,u), lerp(n01,n11,u), v);
};
const fbm=(x,y)=>{let val=0,amp=0.6,freq=1.0; for(let i=0;i<4;i++){val+=amp*noise(x*freq,y*freq); amp*=0.5; freq*=2.02;} return val;};
const lpos=landGeo.attributes.position;
for(let i=0;i<lpos.count;i++){const x=lpos.getX(i)/SIZE+10.5, y=lpos.getY(i)/SIZE+10.5; lpos.setZ(i, fbm(x,y)*0.48*HALF);}
lpos.needsUpdate=true; landGeo.computeVertexNormals();
const land=new THREE.LineSegments(new THREE.EdgesGeometry(landGeo), new THREE.LineBasicMaterial({color:0xeaeaea,transparent:true,opacity:1}));
land.rotation.x=-Math.PI/2; land.position.y=HALF-0.001; scene.add(land);
const topHeights=new Float32Array(lpos.count); for(let i=0;i<lpos.count;i++) topHeights[i]=lpos.getZ(i);

// Strata stack
const strataGroup=new THREE.Group(); scene.add(strataGroup);
function makeStratum(i){
  const t=i/(STRATA_COUNT-1), g=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop), p=g.attributes.position;
  const blend=lerp(0.75,0.35,t), amp=lerp(0.20,0.10,t)*HALF, freq=1.0+t*1.6, off=t*3.14159;
  for(let j=0;j<p.count;j++){
    const x=p.getX(j)/SIZE+10.5, y=p.getY(j)/SIZE+10.5; const base=topHeights[j]||0;
    const n=fbm((x+off)*freq,(y-off)*freq);
    const candidate=(blend*base+(1.0-blend)*(n*0.48*HALF));
    p.setZ(j,(candidate/(0.48*HALF))*amp);
  }
  p.needsUpdate=true; g.computeVertexNormals();
  const edges=new THREE.EdgesGeometry(g), opacity=lerp(0.5,0.1,t);
  const mat=new THREE.LineBasicMaterial({c


      renderer.domElement.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); setTimeout(()=>location.reload(), 150); }, false);
    })();
  </script>
</body>
</html>

