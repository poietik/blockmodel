<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RealGold — Hero (ULTRA-LITE DEBUG, transparent)</title>
<style>
  html,body{height:100%;background:transparent!important;margin:0}
  #rg-root{position:fixed;inset:0;background:transparent!important;touch-action:none;cursor:grab}
  #rg-root.scrubbing{cursor:grabbing}
  canvas{display:block;width:100%;height:100%;background:transparent!important}
  .rg-fallback{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#ccc;font:14px/1.4 ui-sans-serif,system-ui;padding:1rem;text-align:center}
  .rg-error{position:absolute;left:8px;right:8px;bottom:8px;background:#2b0000;color:#ffd7d7;border:1px solid #ff7373;border-radius:8px;padding:10px;font:12px/1.4 ui-sans-serif,system-ui;white-space:pre-wrap}
</style>
</head>
<body>
<div id="rg-root" aria-label="3D gold-in-ground visualization; drag horizontally to scrub the scan" role="img"></div>
<noscript><div class="rg-fallback">Enable JavaScript to view the visualization.</div></noscript>

<script>
(function(){
  const qs = new URLSearchParams(location.search || "");
  window.__RG_CFG__ = {
    zoom: Math.max(0.75, Math.min(2.0, parseFloat(qs.get('zoom')||'1.4'))),
    dpr:  parseFloat(qs.get('dpr')||'0')
  };
})();
</script>

<script>
(function loadThree(urls){
  function showError(msg, err){
    const el = document.getElementById('rg-root');
    const box = document.createElement('div');
    box.className = 'rg-error';
    box.textContent = '[RealGold Hero] ' + msg + (err ? '\n' + (err.stack || err.message || err) : '');
    el.appendChild(box);
    if (err) console.error('[RealGold Hero] ' + msg, err);
  }

  function next(){
    if(!urls.length){ showError('Failed to load THREE from all CDNs.'); return; }
    const src = urls.shift();
    const s = document.createElement('script');
    s.src = src; s.async = true;
    s.onload = function(){ if(!window.THREE){ next(); } else { try { start(); } catch(e){ showError('Runtime error after THREE loaded.', e); } } };
    s.onerror = function(e){ s.remove(); next(); };
    document.head.appendChild(s);
  }
  next();

  function start(){
    const THREE = window.THREE;
    const el = document.getElementById('rg-root');

    // Guards
    try {
      const c = document.createElement('canvas');
      const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
      if(!gl){ el.innerHTML = '<div class="rg-fallback">WebGL not available.</div>'; return; }
    } catch(e) { showError('WebGL init error', e); return; }

    // Helpers
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const lerp = (a,b,t)=>a+(b-a)*t;
    const clamp01 = x=>Math.max(0, Math.min(1, x));
    const fade = t=>t*t*t*(t*(t*6-15)+10);
    const mulberry32 = a => () => { let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; };

    // Renderer (transparent)
    const DPR = Math.min((window.__RG_CFG__.dpr>0?window.__RG_CFG__.dpr:(window.devicePixelRatio||1)), isMobile?1.25:2);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:isMobile?'low-power':'high-performance' });
    renderer.setPixelRatio(DPR);
    renderer.setSize(el.clientWidth, el.clientHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.localClippingEnabled = true;
    el.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // Camera (ZOOM makes cube larger by shrinking ortho)
    let camera;
    const BASE_ORTHO = 3.6;
    function makeOrtho(){
      const aspect = el.clientWidth / el.clientHeight || 1;
      const h = (BASE_ORTHO / (window.__RG_CFG__.zoom || 1.4));
      const w = h * aspect;
      camera = new THREE.OrthographicCamera(-w, w, h, -h, 0.1, 100);
      camera.position.set(4,4,4);
      camera.lookAt(0,0,0);
    }
    makeOrtho();
    window.addEventListener('resize', ()=>{ try{ renderer.setSize(el.clientWidth, el.clientHeight); makeOrtho(); }catch(e){ showError('Resize error', e); } });

    // Constants
    const SIZE=2.4, HALF=SIZE/2, SCAN_H=0.008*SIZE, STRATA=isMobile?24:48, gridTop=isMobile?64:96;

    // Smoke test (draw a tiny triangle in the corner quickly)
    try{
      const smoke = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(0.2,0.2,0.2)),
        new THREE.LineBasicMaterial({color:0x444444, transparent:true, opacity:0.6})
      );
      smoke.position.set(-HALF*0.8, -HALF*0.8, -HALF*0.8);
      scene.add(smoke);
      renderer.render(scene, camera);
      scene.remove(smoke); // passed
    }catch(e){ showError('Basic render failed', e); return; }

    // Core pieces
    function yFor(t){ return lerp(HALF-0.002-SCAN_H*0.5, -HALF+0.002+SCAN_H*0.5, t); }

    // Wire cube
    scene.add(new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE,SIZE,SIZE)),
      new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity:0.9 })
    ));

    // Crown surface
    const landGeo=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop);
    const rand=mulberry32(777), grad=[];
    for(let i=0;i<=gridTop;i++) grad[i]=Array(gridTop+1).fill(0).map(()=>({x:rand()*2-1,y:rand()*2-1}));
    const noise=(x,y)=>{ const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi;
      const dot=(ix,iy)=>{ const g=grad[(iy%(gridTop+1)+gridTop+1)%(gridTop+1)][(ix%(gridTop+1)+gridTop+1)%(gridTop+1)]; return g.x*(x-ix)+g.y*(y-iy); };
      const u=fade(xf), v=fade(yf); const n00=dot(xi,yi), n10=dot(xi+1,yi), n01=dot(xi,yi+1), n11=dot(xi+1,yi+1);
      return lerp(lerp(n00,n10,u), lerp(n01,n11,u), v);
    };
    const fbm=(x,y)=>{ let val=0, amp=0.6, freq=1.0; for(let i=0;i<4;i++){ val+=amp*noise(x*freq,y*freq); amp*=0.5; freq*=2.02; } return val; };

    const lpos=landGeo.attributes.position;
    for(let i=0;i<lpos.count;i++){ const x=lpos.getX(i)/SIZE+10.5, y=lpos.getY(i)/SIZE+10.5; lpos.setZ(i, fbm(x,y)*0.48*HALF); }
    lpos.needsUpdate=true; landGeo.computeVertexNormals();

    const land=new THREE.LineSegments(new THREE.EdgesGeometry(landGeo), new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity:1 }));
    land.rotation.x=-Math.PI/2; land.position.y=HALF-0.001; scene.add(land);
    const topHeights=new Float32Array(lpos.count); for(let i=0;i<lpos.count;i++) topHeights[i]=lpos.getZ(i);

    // Strata stack
    const strataGroup=new THREE.Group(); scene.add(strataGroup);
    function makeStratum(k){
      const t=k/(STRATA-1), g=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop), p=g.attributes.position;
      const blend=lerp(0.75,0.35,t), amp=lerp(0.20,0.10,t)*HALF, freq=1.0+t*1.6, off=t*3.14159;
      for(let j=0;j<p.count;j++){
        const x=p.getX(j)/SIZE+10.5, y=p.getY(j)/SIZE+10.5, base=topHeights[j]||0;
        const n=fbm((x+off)*freq,(y-off)*freq);
        const candidate=(blend*base + (1.0-blend)*(n*0.48*HALF));
        p.setZ(j,(candidate/(0.48*HALF))*amp);
      }
      p.needsUpdate=true; g.computeVertexNormals();
      const edges=new THREE.EdgesGeometry(g), opacity=lerp(0.5,0.1,t);
      const mat=new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity });
      const mesh=new THREE.LineSegments(edges,mat); mesh.rotation.x=-Math.PI/2; mesh.position.y=yFor(t); mesh.userData.layerIndex=k; return mesh;
    }
    for(let i=1;i<STRATA;i++) strataGroup.add(makeStratum(i));

    // Surface gold specks
    const goldGroup=new THREE.Group(); scene.add(goldGroup);
    function makeGoldPoints(k){
      const t=k/(STRATA-1), y=yFor(t), count=isMobile?40:80, geo=new THREE.BufferGeometry(), pos=new Float32Array(count*3);
      let n=0, tries=0; while(n<count && tries<count*10){ tries++;
        const x=(Math.random()-0.5)*SIZE*0.92, z=(Math.random()-0.5)*SIZE*0.92;
        const sx=x/SIZE+10.5+t*3.14159, sy=z/SIZE+10.5-t*3.14159, fq=1.0+t*1.6;
        const v=fbm(sx*fq, sy*fq);
        if(v>0.36+t*0.1){ pos[n*3]=x; pos[n*3+1]=y+(Math.random()-0.5)*SCAN_H*0.6; pos[n*3+2]=z; n++; }
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos.subarray(0,n*3),3));
      const mat=new THREE.PointsMaterial({ color:0xc9a227, size:isMobile?0.014:0.018, transparent:true, opacity:0.45, depthWrite:false, blending:THREE.AdditiveBlending });
      const pts=new THREE.Points(geo,mat); pts.userData.layerIndex=k; return pts;
    }
    for(let i=0;i<STRATA;i++) goldGroup.add(makeGoldPoints(i));

    // Scan slice + glow trail
    const SCAN=new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE*0.985,SCAN_H,SIZE*0.985)), new THREE.LineBasicMaterial({ color:0xc9a227 }));
    const GLOW=new THREE.Mesh(new THREE.BoxGeometry(SIZE*0.985,SCAN_H,SIZE*0.985), new THREE.MeshBasicMaterial({ color:0xc9a227, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending }));
    const GLOW_T1=GLOW.clone(); GLOW_T1.material=GLOW.material.clone(); GLOW_T1.material.opacity=0.07; GLOW_T1.scale.y=1.8;
    const GLOW_T2=GLOW.clone(); GLOW_T2.material=GLOW.material.clone(); GLOW_T2.material.opacity=0.04; GLOW_T2.scale.y=3.0;
    scene.add(SCAN,GLOW,GLOW_T1,GLOW_T2);

    // Clip land above slice
    const plane=new THREE.Plane(new THREE.Vector3(0,-1,0),0);
    const clipMat=new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true, clippingPlanes:[plane], transparent:true, opacity:0.18 });
    const clipLand=new THREE.Mesh(landGeo.clone(), clipMat); clipLand.rotation.x=-Math.PI/2; clipLand.position.y=HALF-0.001; scene.add(clipLand);

    // Diagonal 2× orebody (point cloud)
    const oreUniforms={uSliceY:{value:0.0}, uSliceLagY:{value:0.0}, uW:{value:0.10}};
    const ORE_POINTS=isMobile?4000:7000, rngOre=mulberry32(424242);
    const opos=new Float32Array(ORE_POINTS*3);
    const p0=new THREE.Vector3(-HALF*0.65,-HALF*0.25, HALF*0.65);
    const p1=new THREE.Vector3( HALF*0.65, HALF*0.65,-HALF*0.65);
    const dir=new THREE.Vector3().subVectors(p1,p0);
    for(let i=0;i<ORE_POINTS;i++){
      const t=i/ORE_POINTS; const base=new THREE.Vector3().copy(p0).addScaledVector(dir, t+(rngOre()-0.5)*0.06);
      base.x+=(rngOre()-0.5)*0.60; base.y+=(rngOre()-0.5)*0.34; base.z+=(rngOre()-0.5)*0.60;
      opos[i*3]=base.x; opos[i*3+1]=base.y; opos[i*3+2]=base.z;
    }
    const oreGeo=new THREE.BufferGeometry(); oreGeo.setAttribute('position', new THREE.BufferAttribute(opos,3));
    const oreMat=new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uSliceY:oreUniforms.uSliceY, uSliceLagY:oreUniforms.uSliceLagY, uW:oreUniforms.uW,
                 uBase:{value:new THREE.Color(0x4a3d12)}, uGold:{value:new THREE.Color(0xc9a227)},
                 uSize:{value:isMobile?2.0:2.6} },
      vertexShader:'uniform float uSliceY,uSliceLagY,uW,uSize; varying float vH;'+
                   'void main(){ vec4 w=modelMatrix*vec4(position,1.0); float d=min(abs(w.y-uSliceY),abs(w.y-uSliceLagY));'+
                   'vH=smoothstep(uW*1.2,0.0,d); gl_Position=projectionMatrix*viewMatrix*w; gl_PointSize=uSize*(1.0+1.6*vH); }',
      fragmentShader:'precision mediump float; varying float vH; uniform vec3 uBase,uGold;'+
                     'void main(){ vec2 uv=gl_PointCoord-0.5; float r=length(uv); if(r>0.5) discard;'+
                     'float core=smoothstep(0.5,0.0,r); vec3 col=mix(uBase,uGold,vH); float a=core*(0.10+0.90*vH);'+
                     'gl_FragColor=vec4(col,a);} '
    });
    scene.add(new THREE.Points(oreGeo,oreMat));

    // Sparkle near slice
    const SPARK=isMobile?1000:1600; const s=new Float32Array(SPARK*3);
    for(let i=0;i<SPARK;i++){ s[i*3]=(Math.random()-0.5)*SIZE*0.86; s[i*3+1]=(Math.random()-0.5)*SIZE*0.86; s[i*3+2]=(Math.random()-0.5)*SIZE*0.86; }
    const sparkGeo=new THREE.BufferGeometry(); sparkGeo.setAttribute('position', new THREE.BufferAttribute(s,3));
    const sparkMat=new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uSliceY:{value:0.0}, uSliceLagY:{value:0.0}, uW:{value:0.10}, uSize:{value:isMobile?1.5:1.8},
                 uBase:{value:new THREE.Color(0x5a4a12)}, uGold:{value:new THREE.Color(0xc9a227)} },
      vertexShader:'uniform float uSliceY,uSliceLagY,uW,uSize; varying float vH;'+
                   'void main(){ vec4 w=modelMatrix*vec4(position,1.0); float d=min(abs(w.y-uSliceY),abs(w.y-uSliceLagY));'+
                   'vH=smoothstep(uW*1.2,0.0,d); gl_Position=projectionMatrix*viewMatrix*w; gl_PointSize=uSize*(1.0+1.4*vH);} ',
      fragmentShader:'precision mediump float; varying float vH; uniform vec3 uBase,uGold;'+
                     'void main(){ vec2 uv=gl_PointCoord-0.5; float r=length(uv); if(r>0.5) discard;'+
                     'float core=smoothstep(0.5,0.0,r); vec3 col=mix(uBase,uGold,vH); float a=core*(0.05+0.95*vH);'+
                     'gl_FragColor=vec4(col,a);} '
    });
    scene.add(new THREE.Points(sparkGeo,sparkMat));

    // Input + animation
    let tAcc=0, dir=1, user=false, resumeTimer=null;
    const SPEED=isMobile?0.144:0.192, RESUME=550;

    function setFromX(x){ const r=renderer.domElement.getBoundingClientRect(); tAcc=clamp01((x-r.left)/r.width); }
    renderer.domElement.addEventListener('pointerdown',e=>{ renderer.domElement.setPointerCapture(e.pointerId); user=true; el.classList.add('scrubbing'); clearTimeout(resumeTimer); setFromX(e.clientX); e.preventDefault(); }, {passive:false});
    renderer.domElement.addEventListener('pointermove',e=>{ if(user) setFromX(e.clientX); }, {passive:true});
    function end(){ if(!user) return; user=false; el.classList.remove('scrubbing'); clearTimeout(resumeTimer); resumeTimer=setTimeout(()=>{},RESUME); }
    renderer.domElement.addEventListener('pointerup',end,{passive:true});
    renderer.domElement.addEventListener('pointerleave',end,{passive:true});
    renderer.domElement.addEventListener('pointercancel',end,{passive:true});

    let visible=true;
    if('IntersectionObserver' in window){
      (new IntersectionObserver(e=>{ visible = e[0] ? e[0].isIntersecting : true; }, {threshold:0.1})).observe(el);
    }

    let yLag1=0.0, yLag2=0.0;
    const clock=new THREE.Clock();

    function frame(){
      try{
        const dt=clock.getDelta();
        if(!user){ tAcc += dir*SPEED*dt; if(tAcc>1){tAcc=1;dir=-1;} else if(tAcc<0){tAcc=0;dir=1;} }
        const y=yFor(tAcc);
        const k1=4.0, k2=2.0; yLag1+=(y-yLag1)*k1*dt; yLag2+=(y-yLag2)*k2*dt;

        SCAN.position.y=y; GLOW.position.y=y; GLOW_T1.position.y=yLag1; GLOW_T2.position.y=yLag2;
        plane.constant=HALF-y;

        oreUniforms.uSliceY.value=y; oreUniforms.uSliceLagY.value=yLag1;
        sparkMat.uniforms.uSliceY.value=y; sparkMat.uniforms.uSliceLagY.value=yLag1;

        // Subtle motion + near-layer fade
        const idx=tAcc*(STRATA-1), fall=6, et=clock.elapsedTime;
        land.rotation.z=Math.sin(et*0.08)*0.002;
        strataGroup.children.forEach(ch=>{ const d=Math.abs((ch.userData.layerIndex||0)-idx); const near=Math.max(0,1-d/fall);
          ch.material.opacity = lerp(0.05, 0.6, near);
          ch.material.color.setHex(d<0.5?0xffffff:0xeaeaea);
        });

        renderer.render(scene,camera);
      } catch(e){ showError('Frame error', e); }
    }

    (function loop(){ if(visible) frame(); requestAnimationFrame(loop); })();
  }
})([
  'https://unpkg.com/three@0.160.0/build/three.min.js',
  'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js'
]);
</script>
</body>
</html>
